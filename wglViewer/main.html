<!DOCTYPE html>
<!-- Ported from the OpenGL Samples Pack https://github.com/g-truc/ogl-samples/blob/master/tests/gl-320-texture-3d.cpp -->
<html lang="en">

<head>
    <title>WebGL 2 HistoPyramids</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="utility.js"></script>
    <script src="third-party/gl-matrix-min.js"></script>
    <script src="third-party/noise3D.js"></script>
    <script src="third-party/nifti-reader.js"></script>
    <script src="third-party/stats.min.js"></script>

    <script src="src/createAndCompileShader.js"></script>
    <script src="src/createComputeProgram.js"></script>
    <script src="src/createRenderProgram.js"></script>

    <script src="src/frame.js"></script>
    <script src="src/volume.js"></script>
    <script src="src/tables.js"></script>


    <script src="src/generateTexture.js"></script>
    <script src="src/render.js"></script>

    <script src="shaders/renderScreen.js"></script>
    <script src="shaders/renderScreenMarchingCubes.js"></script>
    <script src="shaders/histoPyramidSource.js"></script>

    <script type="text/javascript">
        function uploadVolumeData(header, imageData) {

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_3D, gl.textureVolume);

            gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, header.dims[1], header.dims[2], header.dims[3], gl.RED, gl.FLOAT, new Float32Array(imageData));

            gl.generateMipmap(gl.TEXTURE_3D);


        }
        function readNIFTI(name, buf) {
            var data = nifti.Utils.toArrayBuffer(buf);

  
            buf = nifti.decompress(buf);
            

            var header = nifti.readHeader(buf);

            var imageData = nifti.readImage(header, buf);
            
            uploadVolumeData(header, imageData);

            //var logger = document.getElementById('results');
            //logger.innerText = header.toFormattedString();
        }
        function makeSlice(file, start, length) {
            var fileType = (typeof File);
            if (fileType === 'undefined') {
                return function () {};
            }
            if (File.prototype.slice) {
                return file.slice(start, start + length);
            }
            if (File.prototype.mozSlice) {
                return file.mozSlice(start, length);
            }
            if (File.prototype.webkitSlice) {
                return file.webkitSlice(start, length);
            }
            return null;
        }
        function readFile(file) {
            var blob = makeSlice(file, 0, file.size);
            var reader = new FileReader();
            reader.onloadend = function (evt) {
                if (evt.target.readyState === FileReader.DONE) {
                    readNIFTI(file.name, evt.target.result);
                }
            };
            reader.readAsArrayBuffer(blob);

        }
        function handleFileSelect(evt) {
            var files = evt.target.files;
            readFile(files[0]);
        }
    </script>

</head>

<body>


    <div id="select" style="font-family:sans-serif">
        <p>Select a file: <input type="file" id="file" name="files" /></p>
        <hr />
    </div>


    <script type="text/javascript">
        document.getElementById('file').addEventListener('change', handleFileSelect, false);
    </script>

<div class="slidecontainer">
    <p>level: <span id="isoLevelText"></span></p>
    <input type="range" min="0.0" max="5000" step="10" value="1000" class="slider" id="isoLevelSlider">
  </div>



    <script>

        var gl;

        function divup(a, b) { return (a % b != 0) ? (a / b + 1) : (a / b); }

        var stats = new Stats();
        stats.showPanel(0);
        stats.domElement.style.cssText = 'position:absolute;top:0px;right:0px;';
        document.body.appendChild(stats.dom);


    (function() {
        'use strict';

        var sliderIsoLevel = document.getElementById("isoLevelSlider");
        var textIsoLevel = document.getElementById("isoLevelText");
        var threshChanged = 1;

  sliderIsoLevel.oninput = function() {
    textIsoLevel.innerHTML = this.value;
    threshChanged = 1 - threshChanged;
  }

        var canvas = document.createElement('canvas');
        canvas.width = Math.min(window.innerWidth, window.innerHeight);
        canvas.height = canvas.width;
        document.body.appendChild(canvas);

        gl = canvas.getContext( 'webgl2-compute', { antialias: false } );
        var isWebGL2 = !!gl;
        if(!isWebGL2) {
            document.getElementById('info').innerHTML = 'webgl2 implementation of histopyramids</a>';
            return;
        }
        const extFloatBuffer = gl.getExtension("EXT_color_buffer_float");
        if (!extFloatBuffer) {
            alert("need EXT_color_buffer_float");
            return;
        }
        const extFloatLinear = gl.getExtension("OES_texture_float_linear");
        if (!extFloatLinear) {
            alert("need OES_texture_float_linear");
            return;
        }
        // -- setup viewport

        var windowSize = {
            x: canvas.width,
            y: canvas.height
        };

        var Corners = {
            TOP_LEFT: 0,
            TOP_RIGHT: 1,
            BOTTOM_RIGHT: 2,
            BOTTOM_LEFT: 3,
            MAX: 4
        };

        var viewport = new Array(1);

        viewport = {
            x: 0,
            y: 0,
            z: windowSize.x,
            w: windowSize.y
        };


        var SIZE = 512;
        var numberofLevels = 10;

        var textureVolume = generateTexture(gl, gl.TEXTURE_3D, gl.R32F, 1, SIZE, SIZE, SIZE, gl.LINEAR, gl.LINEAR_MIPMAP_NEAREST);
        var textureHistoPyramid = generateTexture(gl, gl.TEXTURE_3D, gl.R32UI, 10, SIZE, SIZE, SIZE, gl.NEAREST, gl.NEAREST_MIPMAP_NEAREST);

        var textureTriTable = generateTexture(gl, gl.TEXTURE_2D, gl.R32UI, 1, 256 * 16, 1, 1, gl.NEAREST, gl.NEAREST);
        var textureNrTriangles = generateTexture(gl, gl.TEXTURE_2D, gl.R32UI, 1, 256, 1, 1, gl.NEAREST, gl.NEAREST);
        var textureOffsets3 = generateTexture(gl, gl.TEXTURE_2D, gl.R32UI, 1, 72, 1, 1, gl.NEAREST, gl.NEAREST);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textureTriTable);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 256 * 16, 1, gl.RED_INTEGER, gl.UNSIGNED_INT, triTable);

        gl.bindTexture(gl.TEXTURE_2D, textureNrTriangles);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 256, 1, gl.RED_INTEGER, gl.UNSIGNED_INT, nrOfTriangles);

        gl.bindTexture(gl.TEXTURE_2D, textureOffsets3);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 72, 1, gl.RED_INTEGER, gl.UNSIGNED_INT, offsets3);

        // textureVolume = gl.createTexture();
        // gl.activeTexture(gl.TEXTURE0);
        // gl.bindTexture(gl.TEXTURE_3D, textureVolume);
        // gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_BASE_LEVEL, 0);
        // gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAX_LEVEL, Math.log2(SIZE));
        // gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        // gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        // gl.texStorage3D(gl.TEXTURE_3D, Math.log2(SIZE), gl.R32F, SIZE, SIZE, SIZE);

        //gl.generateMipmap(gl.TEXTURE_3D);

        // -- Initialize program
        var renderProgram = createRenderProgram(gl, vertexShaderSource, fragmentShaderSource);
        var mcRenderProgram = createRenderProgram(gl, mcVertexShaderSource, mcFragmentShaderSource);

        var constructHistoPyramidProgram = createComputeProgram(gl, constructHistoPyramidSource);
        var traverseHistoPyramidProgram = createComputeProgram(gl, traverseHistoPyramidSource);

        var uniformTextureModelViewLocation = gl.getUniformLocation(renderProgram, 'MV');
        var uniformTextureProjectionLocation = gl.getUniformLocation(renderProgram, 'proj');
        var uniformTextureMatrixLocation = gl.getUniformLocation(renderProgram, 'orientation');
        var uniformDiffuseLocation = gl.getUniformLocation(renderProgram, 'volumeData');

        // histopyramid classify cubes program


        // -- Initialize buffer
        //var positions = new Float32Array([
        //    -1.0, -1.0,
        //     1.0, -1.0,
        //     1.0,  1.0,
        //     1.0,  1.0,
        //    -1.0,  1.0,
        //    -1.0, -1.0
        //]);

        var positions = new Float32Array([
                    1.0,	1.0,	0.0,		// top right
                    1.0,	-1.0,	0.0,		 // bottom right
                    -1.0,	-1.0,	0.0,		 // bottom left
                    -1.0,	1.0,	0.0,		  // Top left

                    0.0, 1.0,	1.0,		     // top right
                    0.0, 1.0,  -1.0,		     // bottom right
                    0.0, -1.0, -1.0,		     // bottom left
                    0.0, -1.0,  1.0,		      // Top left

                    1.0,	0.0, 1.0,			 // top right
                    1.0,	0.0, -1.0,		 // bottom right
                    -1.0,	0.0, -1.0,		 // bottom left
                    -1.0,	0.0, 1.0]);



        var vertexPosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        //var texCoords = new Float32Array([
        //    0.0, 1.0,
        //    1.0, 1.0,
        //    1.0, 0.0,
        //    1.0, 0.0,
        //    0.0, 0.0,
        //    0.0, 1.0,
        //]);

        var texCoords = new Float32Array([
        1.0, 1.0, 0.5, // top right
		1.0, 0.0, 0.5, // bottom right
	    0.0, 0.0, 0.5, // bottom left
		0.0, 1.0, 0.5, // Top left

	    0.5, 1.0, 1.0, // top right
		0.5, 1.0, 0.0, // bottom right
		0.5, 0.0, 0.0, // bottom left
		0.5, 0.0, 1.0, // Top left

		1.0, 0.5, 1.0, // top right
		1.0, 0.5, 0.0, // bottom right
		0.0, 0.5, 0.0, // bottom left
		0.0, 0.5, 1.0, // Top left
		]);

        var vertexTexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        var indices = new Uint16Array([
        0, 1, 3, // First Triangle
		1, 2, 3, // Second Triangle

		4, 5, 7,
		5, 6, 7,

		8, 9, 11,
		9, 10, 11,
        ]);

        var indicesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        // -- Initilize vertex array

        var vertexArray = gl.createVertexArray();
        gl.bindVertexArray(vertexArray);

        var vertexPosLocation = 0; // set with GLSL layout qualifier
        gl.enableVertexAttribArray(vertexPosLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
        gl.vertexAttribPointer(vertexPosLocation, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        var vertexTexLocation = 1; // set with GLSL layout qualifier
        gl.enableVertexAttribArray(vertexTexLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexBuffer);
        gl.vertexAttribPointer(vertexTexLocation, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);

        gl.bindVertexArray(null);


 



        let sumOutput = new Float32Array(1);
        var ssboHPSum = gl.createBuffer();
        gl.bindBuffer(gl.SHADER_STORAGE_BUFFER, ssboHPSum);
        gl.bufferData(gl.SHADER_STORAGE_BUFFER, sumOutput, gl.DYNAMIC_COPY);

        let hpVerts = new Float32Array(512*512*512*2); // some large number that we hope will fit in all the verts
        var ssboHPVerts = gl.createBuffer();
        gl.bindBuffer(gl.SHADER_STORAGE_BUFFER, ssboHPVerts);
        gl.bufferData(gl.SHADER_STORAGE_BUFFER, hpVerts, gl.DYNAMIC_COPY, 0, 512*512*512*2);

        let hpNorms = new Float32Array(512*512*512*2); // some large number that we hope will fit in all the norms
        var ssboHPNorms = gl.createBuffer();
        gl.bindBuffer(gl.SHADER_STORAGE_BUFFER, ssboHPNorms);
        gl.bufferData(gl.SHADER_STORAGE_BUFFER, hpNorms, gl.DYNAMIC_COPY, 0, 512*512*512*2);

         var vaoMarchingCubes = gl.createVertexArray();

        gl.bindVertexArray(vaoMarchingCubes);
        var vertLoc = 0;
        gl.enableVertexAttribArray(vertLoc);
        gl.bindBuffer(gl.ARRAY_BUFFER, ssboHPVerts);
        gl.vertexAttribPointer(vertLoc, 4, gl.FLOAT, false, 0, 0);
        var normLoc = 1;
        gl.enableVertexAttribArray(normLoc);
        gl.bindBuffer(gl.ARRAY_BUFFER, ssboHPNorms);
        gl.vertexAttribPointer(normLoc, 4, gl.FLOAT, false, 0, 0);

         gl.bindVertexArray(null);


        var totalSumVerts = 0;

        // -- Render

        var orientation = [0.0, 0.0, 0.0];

        gl.sliderIsoLevel = sliderIsoLevel;

        gl.renderProgram = renderProgram;
        gl.vertexPosBuffer = vertexPosBuffer;
        gl.vertexPosLocation = vertexPosLocation;
        gl.vertexTexBuffer = vertexTexBuffer;
        gl.vertexTexLocation = vertexTexLocation
        gl.indicesBuffer = indicesBuffer;

        gl.mcRenderProgram = mcRenderProgram;

        gl.textureVolume = textureVolume;
        gl.textureHistoPyramid = textureHistoPyramid;

        gl.textureTriTable = textureTriTable;
        gl.textureNrTriangles = textureNrTriangles;
        gl.textureOffsets3 = textureOffsets3;

        gl.constructHistoPyramidProgram = constructHistoPyramidProgram;
        gl.traverseHistoPyramidProgram = traverseHistoPyramidProgram;

        gl.vertexArray = vertexArray;
        gl.vaoMarchingCubes = vaoMarchingCubes;


        gl.orientation = orientation;
        gl.uniformDiffuseLocation = uniformDiffuseLocation;
        gl.uniformTextureModelViewLocation = uniformTextureModelViewLocation;
        gl.uniformTextureProjectionLocation = uniformTextureProjectionLocation;
        gl.uniformTextureMatrixLocation = uniformTextureMatrixLocation;
        gl.size = SIZE;
        gl.orientation = orientation;
        gl.vp = viewport;

        gl.ssboHPSum = ssboHPSum;
        gl.totalSumVerts = totalSumVerts;
        
        gl.ssboHPVerts = ssboHPVerts;
        gl.ssboHPNorms = ssboHPNorms;

        requestAnimationFrame(frameLoop);




function frameLoop() {

    stats.begin();
    
    if (threshChanged == 1)
    {
        classifyCubes(gl);
        constructHistoPyramid(gl);
        traverseHistoPyramid(gl);
        threshChanged = 0;
    }

    render(gl);
    stats.end();

    requestAnimationFrame(frameLoop);
}
    })();
    </script>
    <div id="highlightedLines" style="display: none">#L132-L170</div>

</body>

</html>
